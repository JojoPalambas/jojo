type str_arr = array of string
type str_vect = { strings : str_arr, nb_strings : int }

function stoi(s : string) : int =
    let
        import "lexer.tih"
        var ret : int := 0
        var cur_char : string := ""
    in
        for i := 0 to size(s) - 1 do
        (
            cur_char := cfs(s, i);
            ret := ret * 10;
            ret := ret + ord(cur_char) - ord("0")
        );
        ret
    end

function mod360(n : int) : int =
(
    while (n < 0) do
        n := n + 360;
    while (n >= 360) do
        n := n - 360;
    n
)

function logo(x : int, y : int) : int =
    let
        import "lexer.tih"
        import "libLogo.tih"
        import "line.tih"

        var word_vect : str_vect := lex_input()
        var i : int := 0
        var ret : int := 0

        var dir : int := 0
        var val : int := 0

        var new_x : int := 0
        var new_y : int := 0
    in
        while (i < (word_vect.nb_strings)) do
        (
            if (streq(word_vect.strings[i], "forward")) then
            (
                i := i + 1;
                val := stoi(word_vect.strings[i]);

                new_x := x + ((val * cos(dir)) / trig_cst);
                new_y := y + ((val * sin(dir)) / trig_cst);

                bresenham_line(x, y, new_x, new_y);
                x := new_x;
                y := new_y
            )
            else
            (
                if (streq(word_vect.strings[i], "left")) then
                (
                    i := i + 1;
                    val := stoi(word_vect.strings[i]);
                    dir := mod360(dir + val)
                )
                else
                (
                    if (streq(word_vect.strings[i], "right")) then
                    (
                        i := i + 1;
                        val := stoi(word_vect.strings[i]);
                        dir := mod360(dir - val)
                    )
                    else
                    (
                        print_err("Unknown expression.\n");
                        ret := 1
                    )
                )
            );
            i := i + 1
        );
        ret
    end
